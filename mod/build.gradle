import org.apache.tools.ant.taskdefs.condition.Os

import java.nio.file.Files
import java.nio.file.Paths
import java.nio.file.StandardCopyOption

buildscript {
    repositories {
        jcenter()
        maven {
            name = 'oss-sonatype-public'
            url = 'https://oss.sonatype.org/content/repositories/public/'
        }
        maven {
            name = "forge"
            url = "https://files.minecraftforge.net/maven"
        }
        maven {
            name = 'sponge'
            url = 'http://repo.spongepowered.org/maven'
        }
        maven {
            name = "gradle plugins"
            url 'https://plugins.gradle.org/m2/'
        }
    }
    dependencies {
        classpath "net.minecraftforge.gradle:ForgeGradle:2.3-SNAPSHOT"
        classpath 'org.spongepowered:mixingradle:0.6-SNAPSHOT'
    }
}

plugins {
    id 'com.github.johnrengelman.shadow' version '2.0.4'
}
apply plugin: "net.minecraftforge.gradle.forge"
apply plugin: "org.spongepowered.mixin"
apply plugin: "idea"

String VulkanDllLocation
ext.VulkanDllLocation = VulkanDllLocation
if(file("private-data.gradle").exists() && file("private-data.gradle").isFile()) {
    apply from: "private-data.gradle"
} else if(project.hasProperty("privateDataLocation")) {
    apply from: project.privateDataLocation
}

version = modVersion
group = modGroup
archivesBaseName = modBaseName

targetCompatibility = 1.8
sourceCompatibility = 1.8

minecraft {
    version = project.forgeVersion
    runDir = "run"

    // the mappings can be changed at any time, and must be in the following format.
    // snapshot_YYYYMMDD   snapshot are built nightly.
    // stable_#            stables are built at the discretion of the MCP team.
    // Use non-default mappings at your own risk. they may not always work.
    // simply re-run your setup task after changing the mappings to update your workspace.
    mappings = project.mcpVersion
    // makeObfSourceJar = false // an Srg named sources jar is made by default. uncomment this to disable.

    def args = [
            "-Dfml.coreMods.load=com.continuum.nova.coremod.NovaForgeCoreMod", //the core mod class, needed for mixins
            "-Dmixin.env.compatLevel=JAVA_8", //needed to use java 8 when using mixins
            "-Dmixin.debug.verbose=true", //verbose mixin output for easier debugging of mixins
            "-Dmixin.debug.export=true", //export classes from mixin to runDirectory/.mixin.out
            "-XX:-OmitStackTraceInFastThrow", //without this sometimes you end up with exception with empty stacktrace
            "-Dmixin.checks.interfaces=true", //check if all interface methods are overriden in mixin
            "-ea", //enable assertions
            "-da:io.netty..." //disable netty assertions because they sometimes fail
    ]

    clientJvmArgs.addAll(args)
    serverJvmArgs.addAll(args)
}

repositories {
    mavenCentral()
    maven {
        name = 'sponge'
        url = 'http://repo.spongepowered.org/maven/'
    }
}

configurations {
    shadow
    compile.extendsFrom shadow
}

// mojang's text2speech depends on jna 4.4.0 (which we implcitly depend on), but glm 1.0.1 depends on 4.2.2, so force using the newer one
configurations.all {
    resolutionStrategy {
        force("net.java.dev.jna:jna:4.4.0")
    }
}

dependencies {
    shadow("org.spongepowered:mixin:0.7.8-SNAPSHOT") {
        transitive = false
    }
    shadow(group: 'io.github.java-graphics', name: 'glm', version: '1.0.1')
}

mixin {
    add sourceSets.main, "mixins.nova.refmap.json"
}

jar {
    manifest {
        attributes(
                "TweakClass": "org.spongepowered.asm.launch.MixinTweaker",
                "TweakOrder": 0,
                "MixinConfigs": "mixins.nova.json",
                "FMLAT": "nova_at.cfg",
                "FMLCorePlugin": "com.continuum.nova.coremod.NovaForgeCoreMod"
        )
    }
}

shadowJar {
    configurations = [project.configurations.shadow]

    relocate "benchmark", "shadow.benchmark"
    relocate "dev", "shadow.dev"
    relocate "glf", "shadow.glf"
    relocate "glm", "shadow.glm"
    relocate "jglm", "shadow.jglm"
    relocate "joou", "shadow.joou"
}

reobf {
    //noinspection GroovyMissingReturnStatement
    shadowJar {}
}
build.dependsOn reobfShadowJar
compileJava.outputs.upToDateWhen {false}

processResources {
    // this will ensure that this task is redone when the versions change.
    inputs.property "version", project.version
    inputs.property "mcversion", project.minecraft.version

    // replace stuff in mcmod.info, nothing else
    from(sourceSets.main.resources.srcDirs) {
        include "mcmod.info"

        // replace version and mcversion
        expand "version": project.version, "mcversion": project.minecraft.version
    }

    // copy everything else, thats not the mcmod.info
    from(sourceSets.main.resources.srcDirs) {
        exclude "mcmod.info"
    }

    exclude "META-INF/services/"
    exclude "META-INF/maven/"
}

task packageDefaultShaderpack(type: Zip) {
    from fileTree(dir: "run/shaderpacks/DefaultShaderpack")
    archiveName "DefaultShaderpack.zip"
    destinationDir(file("src/main/resources/defaults"))
}
processResources.mustRunAfter packageDefaultShaderpack
build.dependsOn packageDefaultShaderpack

task generateJniHeaders() {
    doFirst {
        fileTree("../native/mc_interface/jni").each {
            it.delete()
        }
    }

    doLast {
        if(exec {
            commandLine "javah", "-jni", "-cp", sourceSets.main.output.asPath + File.pathSeparator + sourceSets.main.compileClasspath.asPath,
                    "-d", "native/mc_interface/jni", "com.continuum.nova.system.NovaNative"
            workingDir = new File("../")
            standardOutput = prefixedOutputStream("[JNI:GENERATE HEADERS => STDOUT] ", System.out)
            errorOutput = prefixedOutputStream("[JNI:GENERATE HEADERS => STDERR] ", System.err)
        }.exitValue != 0) {
            throw new GradleException("Failed to generate JNI headers")
        }
    }
}
generateJniHeaders.dependsOn compileJava
build.dependsOn generateJniHeaders

void ensureDir(File dir, boolean recreate = false) {
    if(recreate && dir.exists() && dir.isDirectory()) {
        if(!dir.deleteDir()) {
            throw new GradleException("Unable to delete directory ${dir.getAbsolutePath()}")
        }
        ensureDir(dir)
        return
    }

    if (!dir.exists()) {
        if (!dir.mkdirs()) {
            throw new GradleException("Unable to create directory ${dir.getAbsolutePath()}")
        }
    } else if (dir.isFile()) {
        if (!dir.delete()) {
            throw new GradleException("${dir.getAbsolutePath()} is a file and we were unable to delete it, please delete it manually")
        }
        ensureDir(dir)
    }
}

void ensureFile(File file) {
    if(!file.exists()) {
        try {
            if(!file.createNewFile()) {
                throw new IOException("Failed to create ${file.getAbsolutePath()} for unknown reason")
            }
        } catch (IOException e) {
            throw new GradleException("Unable to create file ${file.getAbsolutePath()}", e)
        }
    } else if(file.isDirectory()) {
        if(!file.deleteDir()) {
            throw new GradleException("${dir.getAbsolutePath()} is a directory and we were unable to delete it, please delete it manually")
        }

        ensureFile(file)
    }
}

void ensureCommandWorks(String... cmdline) {
    try {
        if (exec {
            commandLine(cmdline)
            standardOutput = new ByteArrayOutputStream()
            standardInput = new ByteArrayInputStream()
            errorOutput = new ByteArrayOutputStream()
        }.exitValue != 0) {
            throw new GradleException("${cmdline.toArrayString()} exited with non zero exit code")
        }
    } catch (IOException e) {
        throw new GradleException("Failed to run ${cmdline.toArrayString()}", e)
    }
}

OutputStream prefixedOutputStream(String prefix, OutputStream parentStream) {
    OutputStream ret =  new OutputStream() {
        StringBuilder builder = new StringBuilder(prefix)

        @Override
        void write(int i) throws IOException {
            if(i as char == '\n' as char) {
                builder.append(i as char)
                parentStream.write(builder.toString().getBytes())
                parentStream.flush()
                builder.setLength(0)
                builder.append(prefix)
            } else {
                builder.append(i as char)
            }
        }
    }
    return ret
}

File tmpBuildPropsFile = new File(".native-build-props.temp.properties")
ext.tmpBuildPropsFile = tmpBuildPropsFile
Properties loadTmpBuildProps() {
    Properties props = new Properties()
    ensureFile(tmpBuildPropsFile)
    props.load(tmpBuildPropsFile.newReader())
    return props
}

void saveTmpBuildProperties(Properties props) {
    ensureFile(tmpBuildPropsFile)
    props.store(tmpBuildPropsFile.newWriter(false), "MACHINE GENERATED FILE, DO NOT EDIT")
}

task updateSubmodules() {
    doLast {
        if(exec {
            commandLine "git", "submodule", "update", "--init", "--recursive"
            workingDir = new File("../")
            standardOutput = prefixedOutputStream("[GIT:SUBMODULES/STDOUT => GEN] ", System.out)
            errorOutput = prefixedOutputStream("[GIT:SUBMODULES/STDERR => GEN] ", System.err)
        }.exitValue != 0) {
            throw new GradleException("Failed to get git submodules")
        }
    }
}

void buildPlatformRelease() {
    ensureCommandWorks("cmake", "--version")
    Properties buildProperties = loadTmpBuildProps()
    File nativeBuildDir = new File("../native/release-build-platform/")
    ensureDir(nativeBuildDir, true)

    if(exec {
        commandLine "cmake", "../src", "-DCMAKE_BUILD_TYPE=RELEASE", "-G", (Os.isFamily(Os.FAMILY_WINDOWS) ? "MinGW Makefiles" : "Unix Makefiles")
        workingDir = nativeBuildDir
        standardOutput = prefixedOutputStream("[CMAKE/STDOUT => GEN] ", System.out)
        errorOutput = prefixedOutputStream("[CMAKE/STDERR => GEN] ", System.err)
    }.exitValue != 0) {
        throw new GradleException("Failed to invoke cmake for generating makefiles")
    }

    if(exec {
        commandLine "cmake", "--build", ".", "--target", "nova-renderer"
        workingDir = nativeBuildDir
        standardOutput = prefixedOutputStream("[CMAKE/STDOUT => BUILD] ", System.out)
        errorOutput = prefixedOutputStream("[CMAKE/STDERR => BUILD] ", System.err)
    }.exitValue != 0) {
        throw new GradleException("Failed to invoke cmake for building binary")
    }

    buildProperties.setProperty("platform-built", "true")
    buildProperties.setProperty("windows-built", "false")
    buildProperties.setProperty("linux-built", "false")

    if(Os.isFamily(Os.FAMILY_WINDOWS)) {
        buildProperties.setProperty("windows-built", "true")
    } else {
        buildProperties.setProperty("linux-built", "true")
    }

    saveTmpBuildProperties(buildProperties)
}

void buildLinuxRelease() {
    ensureCommandWorks("cmake", "--version")
    Properties buildProperties = loadTmpBuildProps()
    File nativeBuildDir = new File("../native/release-build-linux/")
    ensureDir(nativeBuildDir, true)

    if(exec {
        commandLine "cmake", "../src", "-DCMAKE_BUILD_TYPE=RELEASE",
                "-DCMAKE_TOOLCHAIN_FILE=${new File("../native/toolchains/linux-x86_64.cmake").getAbsolutePath()}",
                "-DCMAKE_C_COMPILER=gcc-8", "-DCMAKE_CXX_COMPILER=g++-8"
        workingDir = nativeBuildDir
        standardOutput = prefixedOutputStream("[CMAKE/STDOUT => GEN/LINUX] ", System.out)
        errorOutput = prefixedOutputStream("[CMAKE/STDERR => GEN/LINUX] ", System.err)
    }.exitValue != 0) {
        throw new GradleException("Failed to invoke cmake for generating makefiles")
    }

    if(exec {
        commandLine "cmake", "--build", ".", "--target", "nova-renderer", "--", "-j${Runtime.getRuntime().availableProcessors()}"
        workingDir = nativeBuildDir
        standardOutput = prefixedOutputStream("[CMAKE/STDOUT => BUILD/LINUX] ", System.out)
        errorOutput = prefixedOutputStream("[CMAKE/STDERR => BUILD/LINUX] ", System.err)
    }.exitValue != 0) {
        throw new GradleException("Failed to invoke cmake for building binary")
    }

    buildProperties.setProperty("platform-built", "false")
    buildProperties.setProperty("linux-built", "true")

    saveTmpBuildProperties(buildProperties)
}

void buildWindowsRelease() {
    ensureCommandWorks("cmake", "--version")
    ensureCommandWorks("x86_64-w64-mingw32-gcc-posix", "--version")
    Properties buildProperties = loadTmpBuildProps()
    File nativeBuildDir = new File("../native/release-build-windows/")
    ensureDir(nativeBuildDir, true)

    if(exec {
        commandLine "cmake", "../src", "-DCMAKE_BUILD_TYPE=RELEASE",
                "-DCMAKE_TOOLCHAIN_FILE=${new File("../native/toolchains/windows-x86_64.cmake").getAbsolutePath()}"
        workingDir = nativeBuildDir
        standardOutput = prefixedOutputStream("[CMAKE/STDOUT => GEN/WINDOWS] ", System.out)
        errorOutput = prefixedOutputStream("[CMAKE/STDERR => GEN/WINDOWS] ", System.err)

        if(VulkanDllLocation != null) {
            File vulkanDllLocationFile = new File("../native/toolchains/vulkan-dll-location.txt").getAbsoluteFile()
            ensureFile(vulkanDllLocationFile)
            vulkanDllLocationFile.write((String) VulkanDllLocation)
        }
    }.exitValue != 0) {
        throw new GradleException("Failed to invoke cmake for generating makefiles")
    }

    if(exec {
        commandLine "cmake", "--build", ".", "--target", "nova-renderer", "--", "-j${Runtime.getRuntime().availableProcessors()}"
        workingDir = nativeBuildDir
        standardOutput = prefixedOutputStream("[CMAKE/STDOUT => BUILD/WINDOWS] ", System.out)
        errorOutput = prefixedOutputStream("[CMAKE/STDERR => BUILD/WINDOWS] ", System.err)
    }.exitValue != 0) {
        throw new GradleException("Failed to invoke cmake for building binary")
    }

    buildProperties.setProperty("platform-built", "false")
    buildProperties.setProperty("windows-built", "true")

    saveTmpBuildProperties(buildProperties)
}

task buildReleaseNatives(dependsOn: updateSubmodules) {
    doLast {
        if ((!Os.isFamily(Os.FAMILY_UNIX) || !System.getProperty("os.arch").contains("64")) || !project.hasProperty("enableCrossBuild")) {
            logger.info("Building platform release")
            buildPlatformRelease()
        } else {
            if(!project.hasProperty("skipWindowsCross")) {
                logger.info("Building windows release")
                buildWindowsRelease()
            }

            if(!project.hasProperty("skipLinuxCross")) {
                logger.info("Building linux release")
                buildLinuxRelease()
            }
        }
    }
}

task copyReleaseBuilds(dependsOn: buildReleaseNatives) {
    doLast {
        final String BASE_DIR = Paths.get("../native").normalize().toString()
        java.nio.file.Path windowsTargetRenderer = Paths.get("src/main/resources/nova-renderer.dll").normalize()

        java.nio.file.Path linuxTargetRenderer = Paths.get("src/main/resources/libnova-renderer.so").normalize()

        Properties buildProperties = loadTmpBuildProps()
        if(Boolean.parseBoolean(buildProperties.getProperty("platform-built", "false"))) {
            if(Os.isFamily(Os.FAMILY_WINDOWS)) {
                Files.copy(Paths.get(BASE_DIR, "release-build-platform/nova-renderer.dll"), windowsTargetRenderer, StandardCopyOption.REPLACE_EXISTING)
            } else {
                Files.copy(Paths.get(BASE_DIR, "release-build-platform/libnova-renderer.so"), linuxTargetRenderer, StandardCopyOption.REPLACE_EXISTING)
            }
            return
        }

        if(Boolean.parseBoolean(buildProperties.getProperty("linux-built", "false"))) {
            Files.copy(Paths.get(BASE_DIR, "release-build-linux/libnova-renderer.so"), linuxTargetRenderer, StandardCopyOption.REPLACE_EXISTING)
        }

        if(Boolean.parseBoolean(buildProperties.getProperty("windows-built", "false"))) {
            Files.copy(Paths.get(BASE_DIR, "release-build-windows/nova-renderer.dll"), windowsTargetRenderer, StandardCopyOption.REPLACE_EXISTING)
        }
    }
}
processResources.mustRunAfter copyReleaseBuilds
build.dependsOn copyReleaseBuilds

task buildDevLibrary(dependsOn: updateSubmodules) {
    File nativeBuildDir
    doFirst {
        ensureCommandWorks("cmake", "--version")
        nativeBuildDir = new File("../native/dev-build").getAbsoluteFile()
        ensureDir(nativeBuildDir)
    }

    doLast {
        if(exec {
            commandLine "cmake", "../src", "-DCMAKE_BUILD_TYPE=DEBUG", "-G", (Os.isFamily(Os.FAMILY_WINDOWS) ? "MinGW Makefiles" : "Unix Makefiles"),
            (Os.isFamily(Os.FAMILY_UNIX) ? "-DCMAKE_C_COMPILER=gcc-8" : ""),
            (Os.isFamily(Os.FAMILY_UNIX) ? "-DCMAKE_CXX_COMPILER=g++-8" : "")
            workingDir = nativeBuildDir
            standardOutput = prefixedOutputStream("[CMAKE/STDOUT => GEN] ", System.out)
            errorOutput = prefixedOutputStream("[CMAKE/STDERR => GEN] ", System.err)
        }.exitValue != 0) {
            throw new GradleException("Failed to invoke cmake for generating makefiles")
        }

        if(exec {
            commandLine "cmake", "--build", ".", "--target", "nova-renderer", "--", "-j${Runtime.getRuntime().availableProcessors()}"
            workingDir = nativeBuildDir
            standardOutput = prefixedOutputStream("[CMAKE/STDOUT => BUILD] ", System.out)
            errorOutput = prefixedOutputStream("[CMAKE/STDERR => BUILD] ", System.err)
        }.exitValue != 0) {
            throw new GradleException("Failed to invoke cmake for building binary")
        }
    }
}

//noinspection GroovyAssignabilityCheck
task copyLibraryToRunDir(type: Copy, dependsOn: buildDevLibrary) {
    from "../native/dev-build"
    into "run"
    if(Os.isFamily(Os.FAMILY_WINDOWS)) {
        include "nova-renderer.dll"
    } else {
        include "libnova-renderer.so"
    }
}

runClient.outputs.upToDateWhen { false }
runClient.standardOutput = System.out
//noinspection GroovyAssignabilityCheck
runClient.dependsOn copyLibraryToRunDir
